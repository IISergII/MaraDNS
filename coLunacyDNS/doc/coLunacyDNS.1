.\# roff document generated by https://github.com/nereusx/md2roff
.\# Hand edited after auto generation
.do mso man.tmac
.TH COLUNACYDNS  Oct 25 2022
coLunacyDNS is a simply IPv4 and IPv6 forwarding DNS server (with support only for IPv4 and IPv6 IP records) controlled by a Lua script. It allows a lot of flexibility because it uses a combination of C for high performance and Lua for maximum control.
.PP
The current version of coLunacyDNS is version 1.0.011, made in January of 2021.
.PP
All example configuration files here are public domain.
.PP
.SH coLunacyDNS startup
.PP
Since coLunacyDNS runs on port 53, we need to start it as root. As soon as coLunacyDNS binds to port 53 and seeds its internal secure pseudo random number generator, it calls '\f[CR]chroot\fP' and drops root privileges. It runs as the user and group with the user ID of 707; this value can be changed by altering '\f[CR]UID\fP' and '\f[CR]GID\fP' in the source code.
.PP
.SH Configration file examples
.PP
In this example, we listen on 127.0.0.1, and, for any IPv4 query, we return the IP of that query as reported by 9.9.9.9.
.PP
.in +4n
.EX
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
function processQuery(Q) -- Called for every DNS query received
   -- Connect to 9.9.9.9 for the query given to this routine
   local t = coDNS.solve({name=Q.coQuery, type="A", 
                          upstreamIp4="9.9.9.9"})
   -- Return a "server fail" if we did not get an answer
   if(t.error or t.status ~= 1) then 
     return {co1Type = "serverFail"} 
   end
   -- Otherwise, return the answer
   return {co1Type = "A", co1Data = t.answer}
end
.EE
.in
As an even simpler example, we always return "10.1.1.1" for any DNS query given to us:
.PP
.in +4n
.EX
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
function processQuery(Q) -- Called for every DNS query received
  return {co1Type = "A", co1Data = "10.1.1.1"}
end
.EE
.in
We can also set the '\f[CR]AA\fP'(authoritative answer) flag, the '\f[CR]RA\fP'(recursion available) flag, and the TTL (time to live) for our answer. In this example, both the '\f[CR]AA\fP' and '\f[CR]RA\fP' flags are set, and the answer is given a time to live of one hour (3600 seconds).
.PP
.in +4n
.EX
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
function processQuery(Q) -- Called for every DNS query received
  return {co1Type = "A", co1Data = "10.1.1.1", 
          co1AA = 1, co1RA = 1, co1TTL = 3600}
end
.EE
.in
In this example, where we bind to both IPv4 and IPv6 localhost, we return '\f[CR]10.1.1.1\fP' for all IPv4 '\f[CR]A\fP' queries, '\f[CR]2001:db8:4d61:7261:444e:5300::1234\fP' for all IPv6 '\f[CR]AAAA\fP' queries, and "not there" for all other query types:
.PP
.in +4n
.EX
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
bindIp6 = "::1" -- Localhost for IPv6
function processQuery(Q) -- Called for every DNS query received
  if Q.coQtype == 28 then
    return {co1Type = "ip6",
            -- 2001:db8:1::234 style also works
            co1Data="2001-0db8-4d61-7261 444e-5300-0000-1234"}
  elseif Q.coQtype == 1 then
    return {co1Type = "A", co1Data = "10.1.1.1"}
  else
    return {co1Type = "notThere"}
  end
end
.EE
.in
Note that coLunacyDNS \fIalways\fP binds to an IPv4 address; if '\f[CR]bindIp\fP' is not set, coLunacyDNS will bind to '\f[CR]0.0.0.0\fP'(all available IPv4 addresses).
.PP
In this example, we contact the DNS server 9.9.9.9 for IPv4 queries, and 149.112.112.112 for IPv6 queries:
.PP
.in +4n
.EX
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
bindIp6 = "::1" -- Localhost for IPv6
function processQuery(Q) -- Called for every DNS query received
  local t
  if Q.coQtype == 28 then -- Request for IPv6 IP
    t = coDNS.solve({name=Q.coQuery,type="ip6", 
                     upstreamIp4="149.112.112.112"})
  elseif Q.coQtype == 1 then -- Request for IPv4 IP
    t = coDNS.solve({name=Q.coQuery, type="A", 
                     upstreamIp4="9.9.9.9"})
  else
    return {co1Type = "notThere"}
  end
  if t.error then
    return {co1Type = "serverFail"}
  end
  if t.status == 28 then
    return {co1Type = "ip6", co1Data = t.answer}
  elseif t.status == 1 then
    return {co1Type = "A", co1Data = t.answer}
  else
    return {co1Type = "notThere"}
  end 
end
.EE
.in
Here is an example where we can synthesize any IP given to us:
.PP
.in +4n
.EX
-- This script takes a query like 10.1.2.3.ip4.internal. and 
-- returns the corresponding IP (e.g. 10.1.2.3 here)
-- We use "internal" because this is the fourth-most commonly used
-- bogus TLD (#1 is "local", #2 is "home", and #3 is "dhcp")

-- Change this is a different top level domain as desired.  So, 
-- if this -- becomes "test", the this configuration script will 
-- resolve "10.1.2.3.ip4.test." names to their IP.
TLD="internal"
-- Change these IPs to the actual IPs the DNS server will run on
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
bindIp6 = "::1" -- Localhost for IPv6

function processQuery(Q) -- Called for every DNS query received
  if Q.coQtype == 1 then
    local query = Q.coQuery
    if query:match("^%d+%.%d+%.%d+%.%d+%.ip4%." .. 
                   TLD .. "%.$") then
      local ip = query:gsub("%.ip4%." .. TLD .. "%.$","")
      return {co1Type = "A", co1Data = ip}
    end
  else
    return {co1Type = "notThere"}
  end
  return {co1Type = "notThere"}
end
.EE
.in
Here is an example of using a block list to block bad domains. The block list is stored in a file with a Deadwood compatible block list; see the file '\f[CR]make.blocklist.sh\fP' in the upper level directory for the tool used to make the file we read to find domains to block.
.PP
.in +4n
.EX
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1
bindIp6 = "::1" -- Localhost for IPv6

-- Open up block list to know which domains to block
blockList = {}
if coDNS.open1("blocklist") then
  line = coDNS.read1()
  while line do
    local name, seen = string.gsub(line,'^ip4%["([^"]+)".*$','%1')
    if seen > 0 then
      blockList[name] = "X"
    end
    line = coDNS.read1()
  end
end

function processQuery(Q) -- Called for every DNS query received
  local upstream = "9.9.9.9"
  local t

  -- Log query
  coDNS.log("Got query for " .. Q.coQuery .. " from " ..
            Q.coFromIP .. " type " ..  Q.coFromIPtype)

  -- Process blocklist
  if blockList[Q.coQuery] == "X" then
    coDNS.log("Name is on block list.")
    return {co1Type = "notThere"}
  end

  -- If not IPv4/IPv6 IP query, send "not there" (like NXDOMAIN)
  if Q.coQtype ~= 1 and Q.coQtype ~= 28 then -- If not IPv4/6
    return {co1Type = "notThere"} -- Send "not there" 
  end

  -- Look for the answer upstream
  if Q.coQtype == 1 then
    t = coDNS.solve({name=Q.coQuery, type="A", 
                     upstreamIp4=upstream})
  else
    t = coDNS.solve({name=Q.coQuery, type="ip6", 
                     upstreamIp4=upstream})
  end
  -- Handle errors; it is not possible to call coDNS.solve() again
  -- in an invocation of processQuery if t.error is set.
  if t.error then
    coDNS.log(t.error)
    return {co1Type = "serverFail"}
  end

  -- If we got an answer we can use, send it to them
  if t.status > 0 and t.answer then
    if t.status == 1 then
      return {co1Type = "A", co1Data = t.answer} 
    elseif t.status == 28 then
      return {co1Type = "ip6", co1Data = t.answer}
    else -- Send notThere for unknown query type
      return {co1Type = "notThere"}
    end
  end
  coDNS.log("Unknown issue (or record not found)")
  return {co1Type = "notThere"}
end
.EE
.in
Here is a complex coLunacyDNS example, which uses a number of features:
.PP
.in +4n
.EX
-- coLunacyDNS configuration
bindIp = "127.0.0.1" -- We bind the server to the IP 127.0.0.1

-- Examples of three API calls we have: 
--   timestamp, rand32, and rand16
--   timestamp is in a non-standard format
--   rand32 and rand16 are high-quality random numbers
coDNS.log(string.format("Timestamp: %.1f",coDNS.timestamp())) 
coDNS.log(string.format("Random32: %08x",coDNS.rand32())) 
coDNS.log(string.format("Random16: %04x",coDNS.rand16())) 
-- Note that it is *not* possible to use coDNS.solve here; 
-- if we attempt to do so, we will get an error with this
-- message:
-- "attempt to yield across metamethod/C-call boundary".  

function processQuery(Q) -- Called for every DNS query received
  -- Because this code uses multiple co-routines, always 
  -- use "local" variables
  local returnIP = nil
  local upstream = "9.9.9.9"

  -- Log query
  coDNS.log("Got IPv4 query for " .. Q.coQuery .. " from " ..
            Q.coFromIP .. " type " ..  Q.coFromIPtype) 

  -- We will use 8.8.8.8 as the upstream server if 
  -- the query ends in ".tj"
  if string.match(Q.coQuery,'%.tj%.$') then
    upstream = "8.8.8.8"
  end

  -- We will use 4.2.2.1 as the upstream server if 
  -- the query comes from 192.168.99.X
  if string.match(Q.coFromIP,'^192%.168%.99%.') then
    upstream = "4.2.2.1"
  end

  if Q.coQtype ~= 1 then -- If it is not an A (ipv4) query
    -- return {co1Type = "ignoreMe"} -- Ignore the query
    return {co1Type = "notThere"} -- Send "not there" 
  end

  -- Contact another DNS server to get our answer
  local t = coDNS.solve({name=Q.coQuery, type="A", 
                         upstreamIp4=upstream})

  -- If coDNS.solve returns an error, the entire processQuery 
  -- routine is "on probation" and unable to run coDNS.solve() 
  -- again (if an attempt is made, the thread will be aborted 
  -- and no DNS response sent downstream).  
  if t.error then	
    coDNS.log(t.error)
    return {co1Type = "serverFail"} 
  end

  -- Status being 0 means we did not get an answer from upstream
  if t.status ~= 0 and t.answer then
    returnIP = t.answer
  end

  if string.match(Q.coQuery,'%.invalid%.$') then
    -- Answer for anything.invalid
    return {co1Type = "A", co1Data = "10.1.1.1"} 
  end
  if returnIP then
    return {co1Type = "A", co1Data = returnIP} 
  end
  return {co1Type = "notThere"} 
end
.EE
.in
.SH Security considerations
.PP
Since the Lua file is executed as root, some effort is made to restrict what it can do:
.PP
.IP \(bu 4
Only the '\f[CR]math\fP', '\f[CR]string\fP', and '\f[CR]bit32\fP' libraries are loaded from Lua's standard libs. (bit32 actually is another Bit library, but with a '\f[CR]bit32\fP' interface.)
.IP \(bu 4
A special '\f[CR]coDNS\fP' library is also loaded.
.IP \(bu 4
The program is designed to give Lua very limted access to the filesystem nor be able to do anything malicious.
.IP \(bu 4
'\f[CR]coDNS.open1()\fP' can only open a file in the directory coLunacyDNS is called from; it can not open files in other directories.
.IP \(bu 4
All DNS '\f[CR]ANY\fP' and '\f[CR]HINFO\fP' queries are given a RFC8482 response.
.PP
.SH Limitations
.PP
coLunacyDNS only processes requests for DNS '\f[CR]A\fP' queries and DNS '\f[CR]AAAA\fP' queries — queries for IPv4 and IPv6 IP addresses. Information about other query types is not available to coLunacyDNS, and it can only return '\f[CR]A\fP' queries, '\f[CR]AAAA\fP' queries, “server fail”, or “this name is not here” in its replies.
.PP
coLunacyDNS, likewise, can only send '\f[CR]A\fP'(IPv4 IP) and '\f[CR]AAAA\fP'(IPv6 IP) requests to upstream servers. While coLunacyDNS can process and forward IPv6 DNS records, and while coLunacyDNS can bind to IPv4 and IPv6 IPs, it can not send queries to upstream DNS servers via IPv6, and '\f[CR]coLunacyDNS\fP' must always have an IPv4 address to bind to.
.PP
.SH The API available to the Lua script
.PP
coLunacyDNS, when running Lua code, has access to the Lua 5.1 versions of the '\f[CR]math\fP' and '\f[CR]string\fP' libraries. The math library has the functions '\f[CR]math.abs\fP', '\f[CR]math.acos\fP', '\f[CR]math.asin\fP', '\f[CR]math.atan\fP', '\f[CR]math.atan2\fP', '\f[CR]math.ceil\fP', '\f[CR]math.cos\fP', '\f[CR]math.cosh\fP', '\f[CR]math.deg\fP', '\f[CR]math.exp\fP', '\f[CR]math.floor\fP', '\f[CR]math.fmod\fP', '\f[CR]math.frexp\fP', '\f[CR]math.huge\fP', '\f[CR]math.ldexp\fP', '\f[CR]math.log\fP', '\f[CR]math.log10\fP', '\f[CR]math.max\fP', '\f[CR]math.min\fP', '\f[CR]math.modf\fP', '\f[CR]math.pi\fP', '\f[CR]math.pow\fP', '\f[CR]math.rad\fP', '\f[CR]math.random\fP', '\f[CR]math.randomseed\fP', '\f[CR]math.sin\fP', '\f[CR]math.sinh\fP', '\f[CR]math.sqrt\fP', '\f[CR]math.tan\fP', and '\f[CR]math.tanh\fP'. Almost all of them are the same as they are in Lua 5.1; the only one which is different is '\f[CR]math.random\fP', which uses RadioGatun[32] instead of '\f[CR]rand\fP' to generate random numbers, '\f[CR]math.randomseed\fP', which takes a string as the random seed (if a number is given, Lua uses coercion to convert the number in to a string), and '\f[CR]math.rand16()\fP'(not available in stock Lua) which returns a 16-bit random integer between 0 and 65535.
.PP
coLunacyDNS also has access to the string library:'\f[CR]string.byte\fP', '\f[CR]string.char\fP', '\f[CR]string.dump\fP', '\f[CR]string.find\fP', '\f[CR]string.format\fP', '\f[CR]string.gmatch\fP', '\f[CR]string.gsub\fP', '\f[CR]string.len\fP', '\f[CR]string.lower\fP', '\f[CR]string.match\fP', '\f[CR]string.rep\fP', '\f[CR]string.reverse\fP', '\f[CR]string.sub\fP', and '\f[CR]string.upper\fP'. All of these are as per Lua 5.1.
.PP
'\f[CR]string.match(str, pattern)\fP', for example, looks for the regular expression '\f[CR]pattern\fP' in the string '\f[CR]str\fP'; regular expression are non-Perl compatible Lua regular expressions. There are number of changes; one being that, instead of using '\f[CR]\\fP' to escape characters, Lua regular expressions use '\f[CR]%\fP'(so '\f[CR]%.\fP' matches against a literal dot, while '\f[CR].\fP' matches against any character).
.PP
While Lua 5.1 does not include the '\f[CR]bit32\fP' library, coLunacyDNS uses a bit manipulation library with an interface like '\f[CR]bit32\fP': The numbers are 32-bit numbers, and the function calls are '\f[CR]bit32.arshift\fP', '\f[CR]bit32.band\fP', '\f[CR]bit32.bnot\fP', '\f[CR]bit32.bor\fP', '\f[CR]bit32.bxor\fP', '\f[CR]bit32.lshift\fP', '\f[CR]bit32.rshift\fP', and '\f[CR]bit32.rrotate\fP'.
.PP
coLunacyDNS also includes a few functions in its own '\f[CR]coDNS\fP' space:
.PP
.IP \(bu 4
'\f[CR]coDNS.log\fP' This takes a single string as its input, and logs the string in question. The logging method depends on the OS being used: In Windows it writes to a log file; in \fINIX it currently outputs the message on standard output. If '\f[CR]logLevel\fP' is 0, its output on \fPNIX is buffered; if '\f[CR]logLevel\fP' is 1 or higher, its output is flushed after every call to coDNS.log.
.IP \(bu 4
'\f[CR]coDNS.timestamp\fP' This returns coLunacyDNS's internal time representation. This is not a standard *NIX timestamp; instead it's a special timestamp generated by coLunacyDNS in a Y2038-compliant manner (in places where '\f[CR]time_t\fP' is 32-bit and we do not have an alternate API to get numbers, we assume negative timestamps are in the future; on Windows 32-bit, we use the Y2038 compatible 64-bit Windows NT '\f[CR]fileTime\fP' timestamps; and on places with a 64-bit '\f[CR]time_t\fP', we consider the timestamp accurate and merely convert it). Each second has 256 ticks.
.IP \(bu 4
'\f[CR]coDNS.rand32\fP' This returns a random integer between 0 and 4294967295.
.IP \(bu 4
'\f[CR]coDNS.rand16\fP' This returns a random integer between 0 and 65535.
.IP \(bu 4
'\f[CR]coDNS.solve\fP' This function, which can only be called inside of '\f[CR]processQuery\fP', requests a DNS record from another DNS server, and returns once the data is available (or if the DNS server does not respond, or if it gives us a reply that we did not get a record). This function is described in more detail in the following section.
.IP \(bu 4
'\f[CR]coDNS.open1\fP', '\f[CR]coDNS.read1\fP', and '\f[CR]coDNS.close1\fP' can be used to read a text file in the same directory that coLunacyDNS is being run from. Details are below, after the '\f[CR]coDNS.solve\fP' section.
.PP
.SH coDNS.solve
.PP
This function is given a table with three members:
.PP
.IP \(bu 4
name, which is the DNS name in human format like '\f[CR]example.com.\fP' The final dot is mandatory
.IP \(bu 4
'\f[CR]type\fP', which can be '\f[CR]A\fP'(IPv4) or '\f[CR]ip6\fP'(IPv6)
.IP \(bu 4
'\f[CR]upstreamIp4\fP', which is the IP connect to; this is a string in IPv4 dotted decimal format, like '\f[CR]10.1.2.3\fP' or '\f[CR]9.9.9.9\fP'. If '\f[CR]upstreamIp4\fP' is not present, coLunacyDNS looks for a global variable called '\f[CR]upstreamIp4\fP' to see if a default value is available.
.PP
It outputs a table with a number of possible elements:
.PP
.IP \(bu 4
'\f[CR]error\fP': If this is in the return table, an error happened which makes it not possible to have '\f[CR]coDNS.solve\fP' run. Errors include giving '\f[CR]coDNS.solve\fP' a bad query for its DNS name; not giving '\f[CR]coDNS.solve\fP' a table when calling it; not having the element '\f[CR]type\fP' in the table given to '\f[CR]coDNS.solve\fP'; etc. Once an error is returned, it is not possible to run '\f[CR]coDNS.solve\fP' again in the current thread; if one calls '\f[CR]coDNS.solve\fP' a second time after getting an error, the thread will be terminated and the client will not receive a DNS reply.
.IP \(bu 4
'\f[CR]status\fP': If we got an IPv4 address from the upstream server, this returns the number 1. If we got an IPv6 address from the upstream server, this returns the number 28 (the DNS number for an IPv6 reply). Otherwise, this returns the number 0.
.IP \(bu 4
'\f[CR]answer\fP': This is the answer we got from the upstream DNS server. If the answer is an IPv4 IP, the answer is a string with a standard dotted decimal IP in it, such as '\f[CR]10.4.5.6\fP'. If the answer is an IPv6 IP, the answer is a string with the IPv6 IP in it, in the form '\f[CR]XXXX-XXXX-XXXX-XXXX XXXX-XXXX-XXXX-XXXX\fP', where each X is a hexadecimal digit, such as '\f[CR]2001-0db8-4d61-7261 444e-5300-0000-0001\fP' All 32 hexadecimal digits that comprise an IPv6 address will be present in the reply string. Should there be a timeout or error getting an answer from the upstream DNS server, this string will have the value '\f[CR]DNS connect error\fP'. Should we get a reply from the upstream DNS server, but an answer was not seen (usually, because we asked for a DNS record which does not exist), the '\f[CR]answer\fP' field will have the string '\f[CR]DNS answer not seen\fP'.
.IP \(bu 4
rawpacket: If the global variable '\f[CR]logLevel\fP' has a value of 0, this will always be '\f[CR]nil\fP'. If '\f[CR]logLevel\fP' is 1, this will be '\f[CR]nil\fP' if we were able to extract an answer from the upstream DNS server; otherwise, this will be an escaped form of the raw packet sent to us from upstream. If '\f[CR]logLevel\fP' is 2 or higher, this will always be an escaped raw packet from upstream. In an escaped packet, characters which are between ASCII '\f[CR]0\fP' and '\f[CR]z\fP' will be shown as is; otherwise, they will be in the form '\f[CR]{1f}\fP', where the hex value of the byte is shown between the brackets ('\f[CR]{\fP' and '\f[CR]}\fP' have an ASCII value above '\f[CR]z\fP').
.PP
Since this function allows other Lua threads to run while it awaits a DNS reply, global variables may change in value while the DNS record is being fetched.
.PP
.SH Reading files
.PP
We have an API which can be used to read files. For example:
.PP
.in +4n
.EX
if not coDNS.open1("filename.txt") then
  return {co1Type = "serverFail"}
end
local line = ""
while line do
  if line then coDNS.log("Line: " .. line) end
  line = coDNS.read1()
end
.EE
.in
The calls are:'\f[CR]coDNS.open1(filename)\fP', '\f[CR]coDNS.read1()\fP', and '\f[CR]coDNS.close1()\fP'. Only a single file can be open at a time. If '\f[CR]coDNS.open1()\fP' is called when a file is open, the currently open file is closed before we attempt to open the new file. If '\f[CR]coDNS.solve()\fP' is called while a file is open, the file is closed before we attempt to solve the DNS query. If we exit '\f[CR]processQuery()\fP' while a file is open, the file is closed as we exit the function. Files are also closed when we finish parsing the Lua configuration file used by coLunacyDNS, before listening to DNS queries. The filename must start with an ASCII letter, number, or the '\f[CR]_\fP'(underscore) character. The filename may contain only ASCII letters, numbers, instances of '\f[CR].\fP'(the dot character), or the '\f[CR]_\fP' character. In particular, the filename may not contain '\f[CR]/\fP', '\f[CR]\\fP', or any other commonly used directory separator.
.PP
If the file is not present, or the filename contains an illegal character, or the file can not be opened, '\f[CR]coDNS.open1\fP' will return a '\f[CR]false\fP' boolean value. Otherwise, '\f[CR]open1\fP' returns the '\f[CR]true\fP' boolean. The file has to be in the same directory that coLunacyDNS is run from. The file may only be read; writing to the file is not possible. '\f[CR]coDNS.read1()\fP' reads a single line from the file. Any newline is stripped from the end (unlike Perl, coLunacyDNS does not require a '\f[CR]chop\fP'); NUL characters in the line also truncate the string read. If a line is read from the file, '\f[CR]coDNS.read1()\fP' returns the line which was read. Otherwise, '\f[CR]coDNS.read1()\fP' returns the '\f[CR]false\fP' Lua boolean value.
.PP
'\f[CR]coDNS.read1()\fP' assumes that a single line will be under 500 bytes in size. Behavior is undefined when trying to read a longer line. '\f[CR]coDNS.close1()\fP' closes an open file; a file is also closed when opening another file, ending '\f[CR]processQuery()\fP', or calling '\f[CR]coDNS.solve()\fP'. It is mainly here to give programmers trained to close open files a function which does so.
.PP
.SH processQuery
.PP
Every time coLunacyDNS gets a query, it runs the lua function processQuery, which takes as its input a table with the following members:
.PP
.IP \(bu 4
'\f[CR]coQuery\fP': This is the DNS name requested, in the form of a string like '\f[CR]caulixtla.com.\fP' or '\f[CR]samiam.org.\fP'(observe the dot at the end of the mmQuery string). If the string has anything besides an ASCII letter, an ASCII number, the '\f[CR]-\fP' character (dash), or the '\f[CR]_\fP' character (underline), the character will be a two-digit hexadecimal number in brackets. If we get the raw UTF-8 query '\f[CR]ñ.samiam.org\fP'(where the first character is a n with a tilde), coQuery will look like '\f[CR]{c3}{b1}.samiam.org.\fP'.
.IP \(bu 4
'\f[CR]coQtype\fP': The is the numeric DNS query type requested. This is a number between 0 and 65535, and corresponds to the DNS query type made. A list of DNS query type numbers is available at https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml 1 is "A", i.e. a request for an IPv4 IP address.
.IP \(bu 4
'\f[CR]coFromIP\fP': This is a string containing, in human-readable format, the IP the query came from. The string will look like '\f[CR]10.9.8.7\fP'.
.IP \(bu 4
'\f[CR]coFromIPtype\fP': This is the string '\f[CR]IPv4\fP'
.PP
The processQuery function returns as its output a table with the following parameters:
.PP
.IP \(bu 4
'\f[CR]co1Type\fP': This is a string which can have the following values:'\f[CR]ignoreMe\fP'(no DNS reply will be sent back to the client), '\f[CR]notThere\fP'(tell the client that this DNS name does not exist for the query type requested), '\f[CR]serverFail\fP'(send a "server fail" to the client), "A"(send an IPv4 IP answer back to the client), or "ip6"(send an IPv6 IP answer back to the client). Please note that '\f[CR]ignoreMe\fP' does not guarantee that coLunacyDNS ignores all DNS queries; coLunacyDNS will always respond to ANY or HINFO queries in a RFC8482 manner; if one wishes to drop all DNS packets, this can be done at the firewall level. This field is mandatory.
.IP \(bu 4
'\f[CR]co1Data\fP': This is to be a string. When '\f[CR]co1Type\fP' is '\f[CR]A\fP', this is an IPv4 IP in dotted decimal format, e.g. '\f[CR]10.1.2.3\fP'. When '\f[CR]co1type\fP' is '\f[CR]ip6\fP', and '\f[CR]co1data\fP' is either a standard IPv6 string, such as '\f[CR]2001:db8:1234::5678\fP', or a string with 32 hexadecimal digits, the IPv6 IP in the string is returned to the client. If the character '\f[CR]_\fP' is in the ip6 string and the character '\f[CR]:\fP' is \fPnot* present in the string, this is treated as if it were the number '\f[CR]0\fP'; the characters '\f[CR] \fP'(space) and '\f[CR]-\fP'(dash) are ignored. For example, both '\f[CR]2001:db8::8\fP' and '\f[CR]2001-0db8-4d61-7261 444e-5300-0000-__01\fP'(without linefeed) are allowed values for '\f[CR]co1data\fP' when '\f[CR]co1type\fP' is '\f[CR]ip6\fP'. This field is mandatory when '\f[CR]co1type\fP' is '\f[CR]A\fP' or '\f[CR]ip6\fP'.
.IP \(bu 4
'\f[CR]co1AA\fP': This field, when set with the numeric value of 1, gives the '\f[CR]AA\fP' flag in the DNS reply a value of true; in other words, the DNS answer is marked as “authoritative”. This field is optional; if not set, the reply is \fInot\fP marked authoritative.
.IP \(bu 4
'\f[CR]co1RA\fP': This field, when set with the numeric value of 1, gives the '\f[CR]RA\fP' flag in the DNS reply a value of true, indicating that the coLunacyDNS server can process recursive queries. This field is optional; if not set, the reply is \fInot\fP marked as having recursion available.
.IP \(bu 4
'\f[CR]co1TTL\fP': This numeric field, if set, determines the DNS TTL (suggested time to live for the record) of the reply. This is the TTL in raw seconds, and can have a value between 0 (do not cache) and 7777777 (cache for just over 90 days). This field is optional; if not set, the TTL returned will be 0 (do not cache).
.PP
.SH Global settings 
.PP
coLunacyDNS Lua scripts have three special global variables which are read to adjust settings in coLunacyDNS:
.PP
.IP \(bu 4
'\f[CR]bindIp\fP': This is the IPv4 IP that coLunacyDNS will use as a DNS server. If this is not set, then coLunacyDNS will bind to the IP '\f[CR]0.0.0.0\fP'(all IP addresses the machine running coLunacyDNS has)
.IP \(bu 4
'\f[CR]bindIp6\fP': This is the IPv6 IP that coLunacyDNS will bind to. If this is not set, coLunacyDNS will only bind to IPv4. The IP address is in standard IPv6 format, e.g. '\f[CR]2001:0db8:f00:ba4::2020\fP' or in MaraDNS-specific format, e.g. '\f[CR]2001-0db8-0f00-0ba4 00__00__00__2020\fP'
.IP \(bu 4
'\f[CR]logLevel\fP': If this is set, more information will be logged and passed to Lua scripts which can be used for debugging purposes. This can have a value between 0 and 10; higher values result in more logging. If '\f[CR]logLevel\fP' has a value of 0, log messages generated with '\f[CR]coDNS.log\fP' are buffered and will not immediately be visible; if '\f[CR]logLevel\fP' has a value more than 0, '\f[CR]coDNS.log\fP' messages are immediately flushed (unbuffered).
.PP
.SH Test coverage
.PP
'\f[CR]coLunacyDNS\fP' is feature complete and stable.
.PP
'\f[CR]coLunacyDNS\fP' is a stable and fully tested DNS server. Test coverage is at or very near 100%
.PP
Note: Some blocks of code, sanity tests to make sure we're not in a corner case which can not be readily replicated, have been removed from the testing code via '\f[CR]#ifdef\fP'. Read sqa/README.md for details.
.PP
